const std = @import("std");
const readFileToBuffer = @import("../file-helpers.zig").readFileToBuffer;
const Point = @import("../Point.zig").Point;

const CellType = enum { Empty, Box, Wall };

const Grid = @import("../Grid.zig").Grid(CellType);

pub fn run(allocator: std.mem.Allocator) !void {
    const buffer = try allocator.alloc(u8, 20000);
    defer allocator.free(buffer);
    const input_length = try readFileToBuffer("input/day15_test.txt", buffer);

    var lines = std.mem.splitSequence(u8, buffer[0 .. input_length - 1], "\n");
    const grid_width = lines.first().len;
    lines.reset();

    var cell_list = std.ArrayList(CellType).init(allocator);
    var current_location = Point{
        .x = 0,
        .y = 0,
    };

    var y_index: usize = 0;
    while (lines.next()) |line| : (y_index += 1) {
        if (line.len == 0) break;

        for (line, 0..) |character, x_index| {
            if (character == '0') {
                try cell_list.append(CellType.Box);
            } else if (character == '#') {
                try cell_list.append(CellType.Wall);
            } else if (character == '@') {
                current_location.x = @as(isize, @intCast(x_index));
                current_location.y = @as(isize, @intCast(y_index));
            } else {
                try cell_list.append(CellType.Empty);
            }
        }
    }

    var grid = Grid{
        .cells = try cell_list.toOwnedSlice(),
        .width = grid_width,
        .height = y_index,
    };

    try printGrid(&grid, allocator);

    while (lines.next()) |line| {
        for (line) |character| {
            if (character == '>') {
                runStep(&grid, &current_location, Point{ .x = 1, .y = 0 });
            } else if (character == '^') {
                runStep(&grid, &current_location, Point{ .x = 0, .y = -1 });
            } else if (character == '<') {
                runStep(&grid, &current_location, Point{ .x = -1, .y = 0 });
            } else if (character == 'v') {
                runStep(&grid, &current_location, Point{ .x = 0, .y = 1 });
            }
        }
    }

    try printGrid(&grid, allocator);
}

fn printGrid(grid: *Grid, allocator: std.mem.Allocator) !void {
    var grid_string = try allocator.alloc(u8, grid.cells.len + grid.height);
    defer allocator.free(grid_string);

    for (0..grid.height) |y_index| {
        for (0..grid.width) |x_index| {
            if (grid.getCell(Point{ .x = @intCast(x_index), .y = @intCast(y_index) })) |cell| {
                switch (cell) {
                    CellType.Empty => grid_string[y_index * grid.width + x_index + y_index] = '\n',
                    CellType.Box => grid_string[y_index * grid.width + x_index + y_index] = '0',
                    CellType.Empty => grid_string[y_index * grid.width + x_index + y_index] = '#',
                }
            }
        }

        grid_string[y_index * grid.width + grid.width + y_index] = '\n';
    }

    std.debug.print("{s}", .{grid_string});
}

fn runStep(grid: *Grid, current_location: *Point, step: Point) !void {
    if (grid.getCell(current_location.add(step))) |cell| {
        if (cell == CellType.Empty) {
            current_location = current_location.add(step);
        }
    }
}
